<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Truck Packer (Axis-aligned heuristic)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin:0; display:flex; height:100vh; }
    #ui { width:360px; padding:12px; box-sizing:border-box; background:#f7f7f7; overflow:auto; border-right:1px solid #ddd; }
    #scene { flex:1; position:relative; }
    h2 { margin:6px 0 8px; }
    label { display:block; margin-top:8px; font-size:13px; }
    input[type="number"], input[type="text"] { width:100%; padding:6px; margin-top:4px; box-sizing:border-box; }
    .box-row { background:#fff; padding:8px; margin:8px 0; border-radius:6px; border:1px solid #e0e0e0; }
    button { padding:8px 12px; margin-top:8px; cursor:pointer; }
    #info { font-size:13px; margin-top:8px; white-space:pre-wrap; }
    .small { font-size:12px; color:#666; }
    #canvasContainer { position:absolute; inset:0; }
  </style>
</head>
<body>
  <div id="ui">
    <h2>3D Truck Packer</h2>
    <div>
      <label>Truck dimensions (feet)</label>
      <div style="display:flex; gap:6px;">
        <input id="truckL" type="number" step="0.1" value="32" placeholder="Length (ft)" />
        <input id="truckW" type="number" step="0.1" value="8" placeholder="Width (ft)" />
        <input id="truckH" type="number" step="0.1" value="8" placeholder="Height (ft)" />
      </div>
      <div class="small">Note: dimensions in feet. You can change truck dimensions anytime.</div>
    </div>

    <hr />

    <h3>Box types</h3>
    <div id="boxList"></div>
    <button id="addBoxBtn">+ Add box type</button>

    <hr />
    <label>Grid step (ft) â€” packing resolution (smaller -> finer but slower)</label>
    <input id="stepSize" type="number" step="0.05" value="0.5" />
    <div class="small">Use 0.25-1.0. 0.5 is a good compromise.</div>

    <button id="packBtn" style="width:100%; background:#1976d2; color:white;">Run Pack</button>
    <button id="resetBtn" style="width:100%; margin-top:6px;">Reset / Clear</button>

    <div id="info"></div>
    <hr />
    <div class="small">Algorithm: layer-by-layer greedy. Boxes are axis-aligned and can be oriented in 6 permutations.</div>
  </div>

  <div id="scene">
    <div id="canvasContainer"></div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    // ---------- UI helpers ----------
    const boxListDiv = document.getElementById('boxList');
    const addBoxBtn = document.getElementById('addBoxBtn');
    const packBtn = document.getElementById('packBtn');
    const resetBtn = document.getElementById('resetBtn');
    const infoDiv = document.getElementById('info');

    let boxTypes = [];

    function createBoxRow(type = {l:2,w:2,h:2, max:999, color:'#'+Math.floor(Math.random()*16777215).toString(16)}) {
      const id = Math.random().toString(36).slice(2,8);
      boxTypes.push({id, ...type});
      renderBoxList();
    }

    function renderBoxList() {
      boxListDiv.innerHTML = '';
      boxTypes.forEach((b, idx) => {
        const row = document.createElement('div');
        row.className = 'box-row';
        row.innerHTML = `
          <label>Box ${idx+1} (ft)</label>
          <div style="display:flex; gap:6px;">
            <input data-id="${b.id}" data-field="l" placeholder="L" type="number" step="0.1" value="${b.l}" />
            <input data-id="${b.id}" data-field="w" placeholder="W" type="number" step="0.1" value="${b.w}" />
            <input data-id="${b.id}" data-field="h" placeholder="H" type="number" step="0.1" value="${b.h}" />
            <input data-id="${b.id}" data-field="max" placeholder="max qty" type="number" step="1" value="${b.max}" />
          </div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
            <div><span class="small">Color: </span><input data-id="${b.id}" data-field="color" type="text" value="${b.color}" /></div>
            <div>
              <button data-action="remove" data-id="${b.id}">Remove</button>
            </div>
          </div>
        `;
        boxListDiv.appendChild(row);
      });

      // attach listeners
      boxListDiv.querySelectorAll('input').forEach(inp => {
        inp.onchange = (e) => {
          const id = inp.dataset.id;
          const field = inp.dataset.field;
          const val = inp.type === 'number' ? parseFloat(inp.value) || 0 : inp.value;
          const b = boxTypes.find(x=>x.id===id);
          if (!b) return;
          b[field] = val;
        };
      });
      boxListDiv.querySelectorAll('button[data-action="remove"]').forEach(btn=>{
        btn.onclick = () => {
          const id = btn.dataset.id;
          boxTypes = boxTypes.filter(x=>x.id !== id);
          renderBoxList();
        };
      });
    }

    addBoxBtn.onclick = ()=> createBoxRow();

    // default one and two boxes
    createBoxRow({l:4,w:4,h:4, max:999, color:'#ff6666'});
    createBoxRow({l:2.5,w:2,h:1.5, max:999, color:'#66aaff'});

    // ---------- Three.js scene ----------
    const container = document.getElementById('canvasContainer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(40, 30, 40);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    window.addEventListener('resize', ()=> {
      renderer.setSize(container.clientWidth, container.clientHeight);
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
    });

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(10,4,0);
    controls.update();

    // lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x888888, 1.0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(50,50,50);
    scene.add(dir);

    // groups
    let truckGroup = new THREE.Group();
    scene.add(truckGroup);

    function clearScene() {
      while (truckGroup.children.length) {
        const ch = truckGroup.children[0];
        ch.geometry?.dispose?.();
        ch.material?.dispose?.();
        truckGroup.remove(ch);
      }
    }

    // grid helper (optional)
    const grid = new THREE.GridHelper(200, 40, 0xcccccc, 0xeeeeee);
    grid.rotation.x = Math.PI/2;
    grid.visible = false;
    scene.add(grid);

    // render loop
    (function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    })();

    // ---------- Packing algorithm ----------
    function aabbOverlap(a,b) {
      // a, b: {x,y,z, l,w,h} axis aligned, x,y,z are min coords
      return !( a.x + a.l <= b.x ||
                b.x + b.l <= a.x ||
                a.y + a.w <= b.y ||
                b.y + b.w <= a.y ||
                a.z + a.h <= b.z ||
                b.z + b.h <= a.z );
    }

    function tryPlaceAt(pos, dims, placed, truck) {
      const cand = {x:pos.x, y:pos.y, z:pos.z, l:dims.l, w:dims.w, h:dims.h};
      // check bounds
      if (cand.x + cand.l - 1e-9 > truck.L || cand.y + cand.w - 1e-9 > truck.W || cand.z + cand.h - 1e-9 > truck.H) return false;
      // check overlap
      for (const p of placed) if (aabbOverlap(p, cand)) return false;
      placed.push(cand);
      return true;
    }

    function generateOrientations(box) {
      const perms = [
        {l:box.l, w:box.w, h:box.h},
        {l:box.l, w:box.h, h:box.w},
        {l:box.w, w:box.l, h:box.h},
        {l:box.w, w:box.h, h:box.l},
        {l:box.h, w:box.l, h:box.w},
        {l:box.h, w:box.w, h:box.l},
      ];
      // dedupe similar shapes
      const seen = new Set();
      return perms.filter(p=>{
        const key = [p.l,p.w,p.h].map(x=>x.toFixed(4)).join(',');
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    function packTruck(truck, boxTypes, step) {
      // truck: {L,W,H}, boxTypes: [{l,w,h, max, color}]
      // heuristic: layer-by-layer (z from 0 up), inside each layer fill rows y and columns x greedily.
      const placed = [];
      const placedInfo = []; // include type index and color
      const stats = boxTypes.map(()=>({placed:0, couldNotPlace:0}));

      // sort box types by base area descending to place big boxes first
      const typesOrder = boxTypes.map((b,i)=>({i, base: b.l*b.w, vol: b.l*b.w*b.h}))
                                 .sort((a,b)=> b.base - a.base)
                                 .map(x=>x.i);

      // z layers
      for (let z = 0; z < truck.H - 1e-9; z += step) {
        // for each layer, attempt to fill floor at z
        // we will maintain a list of filled rectangular footprints on this layer via placed boxes with same z range
        // simple approach: scan y (width) and x (length)
        for (let y = 0; y < truck.W - 1e-9; y += step) {
          for (let x = 0; x < truck.L - 1e-9; x += step) {
            // try each box type in order
            let placedOne = false;
            for (const ti of typesOrder) {
              const b = boxTypes[ti];
              if (stats[ti].placed >= (isFinite(b.max)?b.max:Infinity)) continue;
              // try orientations
              const orients = generateOrientations(b);
              // sort orientations by height ascending (prefer lower height to fit current z) or by base area
              orients.sort((A,B)=> (A.h - B.h) || (B.l*B.w - A.l*A.w));
              for (const o of orients) {
                // can the box sit at z (does it exceed height)
                if (z + o.h - 1e-9 > truck.H) continue;
                // create candidate pos
                const pos = {x, y, z};
                if (tryPlaceAt(pos, o, placed, truck)) {
                  placedInfo.push({type:ti, dims:o, color:b.color, pos});
                  stats[ti].placed += 1;
                  placedOne = true;
                  break;
                }
              }
              if (placedOne) break;
            }
            // continue scanning positions
          }
        }
      }

      // compute couldNotPlace = max - placed if finite
      boxTypes.forEach((b, idx) => {
        if (isFinite(b.max)) {
          const p = stats[idx].placed;
          stats[idx].couldNotPlace = Math.max(0, b.max - p);
        } else {
          stats[idx].couldNotPlace = 0;
        }
      });

      return {placedInfo, stats, placed};
    }

    // ---------- Visualization of truck and boxes ----------
    function drawTruckAndBoxes(truckDims, placedInfo) {
      clearScene();
      // draw transparent box for truck interior (wireframe)
      const outer = new THREE.Mesh(
        new THREE.BoxGeometry(truckDims.L, truckDims.H, truckDims.W),
        new THREE.MeshPhongMaterial({ color:0xffffff, transparent:true, opacity:0.06, side:THREE.DoubleSide })
      );
      // place center: we use coordinates where truck min corner at (0,0,0) => center is half
      outer.position.set(truckDims.L/2, truckDims.H/2, truckDims.W/2);
      truckGroup.add(outer);

      // wireframe edges
      const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(truckDims.L, truckDims.H, truckDims.W));
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x333333}));
      line.position.copy(outer.position);
      truckGroup.add(line);

      // draw floor grid inside truck for reference
      const floorGrid = new THREE.GridHelper(Math.max(truckDims.L, truckDims.W)*2, Math.ceil(Math.max(truckDims.L, truckDims.W)), 0x999999, 0xdddddd);
      floorGrid.rotation.x = Math.PI/2;
      floorGrid.scale.set(1,1,1);
      floorGrid.position.set(truckDims.L/2, 0.001, truckDims.W/2);
      truckGroup.add(floorGrid);

      // draw boxes
      placedInfo.forEach(pi => {
        const geom = new THREE.BoxGeometry(pi.dims.l, pi.dims.h, pi.dims.w);
        const mat = new THREE.MeshPhongMaterial({ color: new THREE.Color(pi.color), opacity:0.9 });
        const mesh = new THREE.Mesh(geom, mat);
        // box center position
        mesh.position.set(pi.pos.x + pi.dims.l/2, pi.pos.z + pi.dims.h/2, pi.pos.y + pi.dims.w/2);
        truckGroup.add(mesh);
      });

      // reposition camera target approx center of truck
      controls.target.set(truckDims.L/2, truckDims.H/2, truckDims.W/2);
      controls.update();
    }

    // ---------- Button handlers ----------
    packBtn.onclick = () => {
      const L = parseFloat(document.getElementById('truckL').value) || 0;
      const W = parseFloat(document.getElementById('truckW').value) || 0;
      const H = parseFloat(document.getElementById('truckH').value) || 0;
      const step = parseFloat(document.getElementById('stepSize').value) || 0.5;
      if (L <= 0 || W <= 0 || H <= 0) {
        alert('Enter valid truck dimensions.');
        return;
      }
      if (boxTypes.length === 0) { alert('Add at least one box type.'); return; }

      // clone box types and ensure numeric values
      const boxes = boxTypes.map(b => ({
        l: Math.max(0.001, parseFloat(b.l) || 0),
        w: Math.max(0.001, parseFloat(b.w) || 0),
        h: Math.max(0.001, parseFloat(b.h) || 0),
        max: isFinite(parseFloat(b.max)) ? Math.max(0, Math.floor(b.max)) : Infinity,
        color: b.color || '#'+Math.floor(Math.random()*16777215).toString(16)
      }));

      // basic validation
      for (const b of boxes) {
        if (b.l <=0 || b.w<=0 || b.h<=0) { alert('All box dimensions must be > 0'); return; }
      }

      infoDiv.textContent = 'Packing... (heuristic)';
      setTimeout(()=>{ // let UI update
        const result = packTruck({L, W, H}, boxes, step);
        drawTruckAndBoxes({L, W, H}, result.placedInfo);

        // summary
        let totPlaced = result.placedInfo.length;
        let totalVolTruck = L*W*H;
        let totVolBoxes = result.placedInfo.reduce((s,p)=> s + p.dims.l*p.dims.w*p.dims.h, 0);
        let summary = `Truck: ${L} Ã— ${W} Ã— ${H} ft  (Volume ${totalVolTruck.toFixed(2)} cu.ft)\n`;
        summary += `Step size: ${step} ft\n\n`;
        boxes.forEach((b, idx) => {
          const s = result.stats[idx];
          summary += `Box ${idx+1}: ${b.l}Ã—${b.w}Ã—${b.h} ft   placed ${s.placed}`;
          if (isFinite(b.max)) summary += ` / requested ${b.max} (not placed ${s.couldNotPlace})`;
          summary += '\n';
        });
        summary += `\nTotal placed boxes: ${totPlaced}\nUsed volume: ${totVolBoxes.toFixed(2)} cu.ft  (${(100*totVolBoxes/totalVolTruck).toFixed(1)}% of truck volume)\n`;
        infoDiv.textContent = summary;
      }, 20);
    };

    resetBtn.onclick = ()=> {
      boxTypes = [];
      renderBoxList();
      clearScene();
      infoDiv.textContent = '';
      createBoxRow({l:4,w:4,h:4, max:999, color:'#ff6666'});
    };

    // initial draw
    drawTruckAndBoxes({L:32, W:8, H:8}, []);
  </script>
</body>
</html>
