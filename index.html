<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Truck Packer (GitHub Pages Ready)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin:0; display:flex; height:100vh; }
    #ui { width:360px; padding:12px; box-sizing:border-box; background:#f7f7f7; overflow:auto; border-right:1px solid #ddd; }
    #scene { flex:1; position:relative; }
    h2 { margin:6px 0 8px; }
    label { display:block; margin-top:8px; font-size:13px; }
    input[type="number"], input[type="text"] { width:100%; padding:6px; margin-top:4px; box-sizing:border-box; }
    .box-row { background:#fff; padding:8px; margin:8px 0; border-radius:6px; border:1px solid #e0e0e0; }
    button { padding:8px 12px; margin-top:8px; cursor:pointer; }
    #info { font-size:13px; margin-top:8px; white-space:pre-wrap; }
    .small { font-size:12px; color:#666; }
    #canvasContainer { position:absolute; inset:0; }
  </style>
</head>
<body>
  <div id="ui">
    <h2>3D Truck Packer</h2>
    <div>
      <label>Truck dimensions (feet)</label>
      <div style="display:flex; gap:6px;">
        <input id="truckL" type="number" step="0.1" value="32" placeholder="Length (ft)" />
        <input id="truckW" type="number" step="0.1" value="8" placeholder="Width (ft)" />
        <input id="truckH" type="number" step="0.1" value="8" placeholder="Height (ft)" />
      </div>
      <div class="small">Note: dimensions in feet. You can change truck dimensions anytime.</div>
    </div>

    <hr />

    <h3>Box types</h3>
    <div id="boxList"></div>
    <button id="addBoxBtn">+ Add box type</button>

    <hr />
    <label>Grid step (ft) — packing resolution (smaller = finer but slower)</label>
    <input id="stepSize" type="number" step="0.05" value="0.5" />
    <div class="small">Use 0.25–1.0. 0.5 is a good compromise.</div>

    <button id="packBtn" style="width:100%; background:#1976d2; color:white;">Run Pack</button>
    <button id="resetBtn" style="width:100%; margin-top:6px;">Reset / Clear</button>

    <div id="info"></div>
    <hr />
    <div class="small">Algorithm: greedy, axis-aligned, 6 orientations. Approximate packing.</div>
  </div>

  <div id="scene">
    <div id="canvasContainer"></div>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    const boxListDiv = document.getElementById('boxList');
    const addBoxBtn = document.getElementById('addBoxBtn');
    const packBtn = document.getElementById('packBtn');
    const resetBtn = document.getElementById('resetBtn');
    const infoDiv = document.getElementById('info');

    let boxTypes = [];

    function createBoxRow(type = {l:2,w:2,h:2, max:999, color:'#'+Math.floor(Math.random()*16777215).toString(16)}) {
      const id = Math.random().toString(36).slice(2,8);
      boxTypes.push({id, ...type});
      renderBoxList();
    }

    function renderBoxList() {
      boxListDiv.innerHTML = '';
      boxTypes.forEach((b, idx) => {
        const row = document.createElement('div');
        row.className = 'box-row';
        row.innerHTML = `
          <label>Box ${idx+1} (ft)</label>
          <div style="display:flex; gap:6px;">
            <input data-id="${b.id}" data-field="l" type="number" step="0.1" value="${b.l}" />
            <input data-id="${b.id}" data-field="w" type="number" step="0.1" value="${b.w}" />
            <input data-id="${b.id}" data-field="h" type="number" step="0.1" value="${b.h}" />
            <input data-id="${b.id}" data-field="max" type="number" step="1" value="${b.max}" />
          </div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
            <div><span class="small">Color: </span><input data-id="${b.id}" data-field="color" type="text" value="${b.color}" /></div>
            <button data-action="remove" data-id="${b.id}">Remove</button>
          </div>
        `;
        boxListDiv.appendChild(row);
      });

      boxListDiv.querySelectorAll('input').forEach(inp => {
        inp.onchange = () => {
          const id = inp.dataset.id;
          const field = inp.dataset.field;
          const val = inp.type === 'number' ? parseFloat(inp.value) || 0 : inp.value;
          const b = boxTypes.find(x=>x.id===id);
          if (!b) return;
          b[field] = val;
        };
      });
      boxListDiv.querySelectorAll('button[data-action="remove"]').forEach(btn=>{
        btn.onclick = () => {
          const id = btn.dataset.id;
          boxTypes = boxTypes.filter(x=>x.id !== id);
          renderBoxList();
        };
      });
    }

    addBoxBtn.onclick = ()=> createBoxRow();
    createBoxRow({l:4,w:4,h:4, max:999, color:'#ff6666'});
    createBoxRow({l:2.5,w:2,h:1.5, max:999, color:'#66aaff'});

    // THREE.js scene
    const container = document.getElementById('canvasContainer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(40, 30, 40);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    window.addEventListener('resize', ()=> {
      renderer.setSize(container.clientWidth, container.clientHeight);
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
    });

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(10,4,0);
    controls.update();

    scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(50,50,50);
    scene.add(dir);

    let truckGroup = new THREE.Group();
    scene.add(truckGroup);

    function clearScene() {
      while (truckGroup.children.length) {
        const ch = truckGroup.children[0];
        ch.geometry?.dispose?.();
        ch.material?.dispose?.();
        truckGroup.remove(ch);
      }
    }

    (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();

    // simple overlap check
    function aabbOverlap(a,b) {
      return !( a.x + a.l <= b.x ||
                b.x + b.l <= a.x ||
                a.y + a.w <= b.y ||
                b.y + b.w <= a.y ||
                a.z + a.h <= b.z ||
                b.z + b.h <= a.z );
    }

    function tryPlaceAt(pos, dims, placed, truck) {
      const cand = {x:pos.x, y:pos.y, z:pos.z, l:dims.l, w:dims.w, h:dims.h};
      if (cand.x + cand.l > truck.L || cand.y + cand.w > truck.W || cand.z + cand.h > truck.H) return false;
      for (const p of placed) if (aabbOverlap(p, cand)) return false;
      placed.push(cand);
      return true;
    }

    function generateOrientations(box) {
      const perms = [
        {l:box.l, w:box.w, h:box.h},
        {l:box.l, w:box.h, h:box.w},
        {l:box.w, w:box.l, h:box.h},
        {l:box.w, w:box.h, h:box.l},
        {l:box.h, w:box.l, h:box.w},
        {l:box.h, w:box.w, h:box.l},
      ];
      const seen = new Set();
      return perms.filter(p=>{
        const key = [p.l,p.w,p.h].map(x=>x.toFixed(4)).join(',');
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }

    function packTruck(truck, boxTypes, step) {
      const placed = [], placedInfo = [];
      const stats = boxTypes.map(()=>({placed:0}));

      const typesOrder = boxTypes.map((b,i)=>({i, base:b.l*b.w})).sort((a,b)=> b.base-a.base).map(x=>x.i);

      for (let z=0; z<truck.H; z+=step) {
        for (let y=0; y<truck.W; y+=step) {
          for (let x=0; x<truck.L; x+=step) {
            for (const ti of typesOrder) {
              const b = boxTypes[ti];
              if (stats[ti].placed >= (isFinite(b.max)?b.max:Infinity)) continue;
              const orients = generateOrientations(b);
              for (const o of orients) {
                if (z + o.h > truck.H) continue;
                const pos = {x,y,z};
                if (tryPlaceAt(pos,o,placed,truck)) {
                  placedInfo.push({type:ti,dims:o,color:b.color,pos});
                  stats[ti].placed++;
                  break;
                }
              }
              if (stats[ti].placed>0) break;
            }
          }
        }
      }
      return {placedInfo, stats, placed};
    }

    function drawTruckAndBoxes(truckDims, placedInfo) {
      clearScene();
      const outer = new THREE.Mesh(
        new THREE.BoxGeometry(truckDims.L, truckDims.H, truckDims.W),
        new THREE.MeshPhongMaterial({ color:0xffffff, transparent:true, opacity:0.06, side:THREE.DoubleSide })
      );
      outer.position.set(truckDims.L/2, truckDims.H/2, truckDims.W/2);
      truckGroup.add(outer);

      const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(truckDims.L, truckDims.H, truckDims.W));
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x333333}));
      line.position.copy(outer.position);
      truckGroup.add(line);

      placedInfo.forEach(pi=>{
        const geom = new THREE.BoxGeometry(pi.dims.l, pi.dims.h, pi.dims.w);
        const mat = new THREE.MeshPhongMaterial({ color:new THREE.Color(pi.color) });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(pi.pos.x + pi.dims.l/2, pi.pos.z + pi.dims.h/2, pi.pos.y + pi.dims.w/2);
        truckGroup.add(mesh);
      });

      controls.target.set(truckDims.L/2, truckDims.H/2, truckDims.W/2);
      controls.update();
    }

    packBtn.onclick = ()=>{
      const L = parseFloat(document.getElementById('truckL').value)||0;
      const W = parseFloat(document.getElementById('truckW').value)||0;
      const H = parseFloat(document.getElementById('truckH').value)||0;
      const step = parseFloat(document.getElementById('stepSize').value)||0.5;
      if(L<=0||W<=0||H<=0){alert('Enter valid dimensions');return;}
      if(boxTypes.length===0){alert('Add at least one box');return;}

      const boxes = boxTypes.map(b=>({
        l:parseFloat(b.l), w:parseFloat(b.w), h:parseFloat(b.h),
        max:isFinite(parseFloat(b.max))?Math.floor(b.max):Infinity,
        color:b.color
      }));

      infoDiv.textContent = 'Packing...';
      setTimeout(()=>{
        const result = packTruck({L,W,H},boxes,step);
        drawTruckAndBoxes({L,W,H},result.placedInfo);
        let summary=`Truck: ${L}×${W}×${H} ft\n`;
        boxes.forEach((b,i)=> summary+=`Box${i+1}: ${b.l}×${b.w}×${b.h} → placed ${result.stats[i].placed}\n`);
        summary+=`Total boxes: ${result.placedInfo.length}`;
        infoDiv.textContent = summary;
      },30);
    };

    resetBtn.onclick=()=>{
      boxTypes=[];renderBoxList();clearScene();infoDiv.textContent='';
      createBoxRow({l:4,w:4,h:4,max:999,color:'#ff6666'});
    };

    drawTruckAndBoxes({L:32,W:8,H:8},[]);
  </script>
</body>
</html>
